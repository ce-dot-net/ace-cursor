/**
 * Unit tests for session_id tracking implementation in Cursor extension
 *
 * Tests the correct session_id flow:
 * 1. session_id is generated by ace_search (per-task UUID, NOT conversation_id)
 * 2. AI must remember session_id from ace_search response
 * 3. AI passes session_id to ace_learn after task completion
 * 4. Stop hook only provides AI-Trail summary (does NOT handle session_id)
 *
 * These tests validate both Unix bash and Windows PowerShell script logic.
 */

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import { spawnSync } from 'child_process';

// Mock vscode module (not available outside VS Code)
vi.mock('vscode', () => ({
	window: {
		showInformationMessage: vi.fn().mockResolvedValue(undefined),
		showWarningMessage: vi.fn().mockResolvedValue(undefined),
		showErrorMessage: vi.fn().mockResolvedValue(undefined),
	},
	workspace: {
		workspaceFolders: [],
		getConfiguration: vi.fn(() => ({
			get: vi.fn(),
		})),
	},
	Uri: {
		joinPath: vi.fn((uri, ...segments) => ({
			fsPath: path.join(uri.fsPath, ...segments),
		})),
	},
}));

describe('Session ID Tracking Implementation', () => {
	// Temporary directory for test files
	let tempDir: string;
	let aceDir: string;
	let scriptsDir: string;

	beforeEach(() => {
		// Create temp directory for test artifacts
		tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'ace-session-test-'));
		aceDir = path.join(tempDir, '.cursor', 'ace');
		scriptsDir = path.join(tempDir, '.cursor', 'scripts');
		fs.mkdirSync(aceDir, { recursive: true });
		fs.mkdirSync(scriptsDir, { recursive: true });
	});

	afterEach(() => {
		// Cleanup temp directory
		if (tempDir && fs.existsSync(tempDir)) {
			fs.rmSync(tempDir, { recursive: true, force: true });
		}
	});

	describe('Stop Hook Script Logic (Unix)', () => {
		const isUnix = process.platform !== 'win32';

		it('should extract status and loop_count (NOT conversation_id)', () => {
			if (!isUnix) {
				return; // Skip on Windows
			}

			const testInput = JSON.stringify({
				status: 'completed',
				loop_count: 0,
			});

			// Stop hook only reads status and loop_count
			const statusResult = spawnSync('bash', ['-c', `echo '${testInput}' | jq -r '.status // empty'`], {
				encoding: 'utf-8',
			});

			const loopResult = spawnSync('bash', ['-c', `echo '${testInput}' | jq -r '.loop_count // 0'`], {
				encoding: 'utf-8',
			});

			expect(statusResult.stdout.trim()).toBe('completed');
			expect(loopResult.stdout.trim()).toBe('0');
		});

		it('should generate AI-Trail summary WITHOUT session_id', () => {
			if (!isUnix) {
				return;
			}

			// Stop hook message does NOT include session_id
			const msg = 'Session complete. AI-Trail: MCP:5 Shell:3 Edits:2 Responses:1. Git: main (abc123). Call ace_learn to capture patterns.';

			expect(msg).toContain('AI-Trail:');
			expect(msg).toContain('Call ace_learn');
			expect(msg).not.toContain('session_id=');
		});

		it('should only generate summary on status=completed and loop_count=0', () => {
			if (!isUnix) {
				return;
			}

			// Test condition: should process
			const shouldProcess = (status: string, loopCount: number) => {
				return status === 'completed' && loopCount === 0;
			};

			expect(shouldProcess('completed', 0)).toBe(true);
			expect(shouldProcess('completed', 1)).toBe(false);
			expect(shouldProcess('running', 0)).toBe(false);
			expect(shouldProcess('failed', 0)).toBe(false);
		});
	});

	describe('Stop Hook Script Logic (Windows)', () => {
		// These tests validate PowerShell logic patterns conceptually
		// Actual PowerShell execution only works on Windows

		it('should extract status and loop_count (no conversation_id)', () => {
			// Test the PowerShell logic pattern (conceptual test)
			const testInput = {
				status: 'completed',
				loop_count: 0,
			};

			// Stop hook only reads status and loop_count
			const status = testInput.status;
			const loopCount = testInput.loop_count;

			expect(status).toBe('completed');
			expect(loopCount).toBe(0);
		});

		it('should generate AI-Trail summary without session_id for Windows', () => {
			// Stop hook message does NOT include session_id
			const msg = 'Session complete. AI-Trail: MCP:5 Shell:3 Edits:2 Responses:1. Git: main (abc123). Call ace_learn to capture patterns.';

			expect(msg).toContain('AI-Trail:');
			expect(msg).toContain('Call ace_learn');
			expect(msg).not.toContain('session_id=');
		});
	});

	describe('Extension Stop Hook Template (Unix)', () => {
		it('should NOT contain conversation_id extraction in Unix script template', () => {
			// The Unix stop hook script template from extension.ts
			const unixScriptTemplate = `#!/bin/bash
# ACE Stop Hook - Aggregates AI-Trail trajectory with git context
# Input: status, loop_count

input=$(cat)
status=$(echo "$input" | jq -r '.status // empty')
loop_count=$(echo "$input" | jq -r '.loop_count // 0')`;

			expect(unixScriptTemplate).not.toContain('conversation_id');
			expect(unixScriptTemplate).toContain('status');
			expect(unixScriptTemplate).toContain('loop_count');
			expect(unixScriptTemplate).toContain('jq -r');
		});

		it('should generate AI-Trail summary without session_id handling', () => {
			const unixMsgTemplate = `
  summary="MCP:$mcp_count Shell:$shell_count Edits:$edit_count Responses:$response_count"
  msg="Session complete. AI-Trail: $summary. Git: $git_branch ($git_hash). Call ace_learn to capture patterns."

  echo "{\\"followup_message\\": \\"$msg\\"}"`;

			expect(unixMsgTemplate).toContain('AI-Trail:');
			expect(unixMsgTemplate).toContain('Call ace_learn');
			expect(unixMsgTemplate).not.toContain('session_id');
		});
	});

	describe('Extension Stop Hook Template (Windows)', () => {
		it('should NOT contain conversation_id extraction in Windows script template', () => {
			const windowsScriptTemplate = `# ACE Stop Hook - Aggregates AI-Trail trajectory with git context
# Input: status, loop_count

$inputJson = [Console]::In.ReadToEnd()
$data = $inputJson | ConvertFrom-Json -ErrorAction SilentlyContinue
$status = $data.status
$loopCount = $data.loop_count`;

			expect(windowsScriptTemplate).not.toContain('conversationId');
			expect(windowsScriptTemplate).toContain('$status');
			expect(windowsScriptTemplate).toContain('$loopCount');
			expect(windowsScriptTemplate).toContain('ConvertFrom-Json');
		});

		it('should generate AI-Trail summary without session_id for Windows', () => {
			const windowsMsgTemplate = `
    $summary = "MCP:$mcpCount Shell:$shellCount Edits:$editCount Responses:$responseCount"
    $msg = "Session complete. AI-Trail: $summary. Git: $gitBranch ($gitHash). Call ace_learn to capture patterns."

    Write-Output "{\`"followup_message\`": \`"$msg\`"}"`;

			expect(windowsMsgTemplate).toContain('AI-Trail:');
			expect(windowsMsgTemplate).toContain('Call ace_learn');
			expect(windowsMsgTemplate).not.toContain('session_id');
		});
	});

	describe('Rules File (ace-patterns.mdc)', () => {
		it('should instruct AI to remember session_id from ace_search', () => {
			const rulesContent = `
## HOW TO USE ace_search

1. **Read the user's task/request**
2. **Call ace_search with the task as query:**
   \`\`\`
   ace_search(query="<user's task description>")
   \`\`\`
3. **IMPORTANT: Note the \`session_id\` in the response** - you'll need it for ace_learn!
4. **Review returned patterns** (5-10 relevant ones)
5. **Apply patterns to implementation**

**Example:**
- User: "Implement JWT authentication"
- You call: \`ace_search(query="JWT authentication")\`
- Returns: \`{ results: [...], session_id: "abc-123-..." }\`
- **Remember session_id "abc-123-..." for ace_learn!**`;

			expect(rulesContent).toContain('Note the `session_id` in the response');
			expect(rulesContent).toContain('Remember session_id');
			expect(rulesContent).toContain('ace_search');
		});

		it('should instruct to pass session_id from ace_search to ace_learn', () => {
			const rulesContent = `
**THEN call ace_learn with the session_id from your earlier ace_search call:**
\`\`\`
ace_learn(
  task="<what you accomplished>",
  trajectory=["<key steps>"],
  success=true,
  output="<lessons learned>",
  git={commit_hash: "<from AI-Trail>", branch: "<from AI-Trail>"},
  session_id="<session_id from ace_search response>"
)
\`\`\``;

			expect(rulesContent).toContain('session_id from ace_search response');
			expect(rulesContent).toContain('ace_learn');
			expect(rulesContent).toContain('session_id=');
		});

		it('should emphasize session_id is critical for attribution', () => {
			const rulesContent = `
**CRITICAL: Always include session_id!**
- The \`session_id\` comes from your ace_search response at the START of the task
- It links this learning to the patterns you searched and used
- This enables pattern attribution tracking on the server`;

			expect(rulesContent).toContain('CRITICAL');
			expect(rulesContent).toContain('session_id');
			expect(rulesContent).toContain('pattern attribution');
			expect(rulesContent).toContain('ace_search response');
		});

		it('should show AI-Trail message format WITHOUT session_id', () => {
			const expectedFormat = 'Session complete. AI-Trail: MCP:X Shell:Y Edits:Z Responses:W. Git: branch (hash). Call ace_learn to capture patterns.';

			expect(expectedFormat).toContain('AI-Trail:');
			expect(expectedFormat).toContain('Call ace_learn');
			expect(expectedFormat).not.toContain('session_id=');
		});
	});

	describe('ace_search Response Format', () => {
		it('should return session_id in ace_search response', () => {
			// Mock ace_search response structure
			const aceSearchResponse = {
				results: [
					{ id: 'pattern-1', content: 'Pattern 1', confidence: 0.9 },
					{ id: 'pattern-2', content: 'Pattern 2', confidence: 0.85 },
				],
				session_id: 'uuid-abc-123-def-456',
				count: 2,
			};

			expect(aceSearchResponse).toHaveProperty('session_id');
			expect(aceSearchResponse.session_id).toBeTruthy();
			expect(typeof aceSearchResponse.session_id).toBe('string');
		});
	});

	describe('ace_learn Input Format', () => {
		it('should accept session_id parameter', () => {
			// Mock ace_learn call structure
			const aceLearnCall = {
				task: 'Implement JWT authentication',
				trajectory: ['Step 1', 'Step 2', 'Step 3'],
				success: true,
				output: 'Successfully implemented JWT auth',
				git: {
					commit_hash: 'abc123',
					branch: 'main',
				},
				session_id: 'uuid-abc-123-def-456',
			};

			expect(aceLearnCall).toHaveProperty('session_id');
			expect(aceLearnCall.session_id).toBeTruthy();
			expect(typeof aceLearnCall.session_id).toBe('string');
		});
	});

	describe('Followup Message Format', () => {
		it('should output valid JSON with followup_message', () => {
			const msg = 'Session complete. AI-Trail: MCP:5 Shell:3 Edits:2 Responses:1. Git: main (abc123). Call ace_learn to capture patterns.';

			const output = { followup_message: msg };

			expect(() => JSON.stringify(output)).not.toThrow();

			const parsed = JSON.parse(JSON.stringify(output));
			expect(parsed.followup_message).toContain('AI-Trail:');
			expect(parsed.followup_message).not.toContain('session_id=');
		});

		it('should escape quotes correctly in Unix bash', () => {
			// Unix uses \" for escaping in echo
			const unixEcho = 'echo "{\\"followup_message\\": \\"$msg\\"}"';

			expect(unixEcho).toContain('\\"');
			expect(unixEcho).toContain('followup_message');
		});

		it('should escape quotes correctly in Windows PowerShell', () => {
			// Windows uses backtick ` for escaping in strings
			const windowsWrite = 'Write-Output "{\`"followup_message\`": \`"$msg\`"}"';

			expect(windowsWrite).toContain('`"');
			expect(windowsWrite).toContain('followup_message');
		});

		it('should return empty JSON when not completed or loop_count > 0', () => {
			const emptyOutput = '{}';

			const parsed = JSON.parse(emptyOutput);
			expect(Object.keys(parsed).length).toBe(0);
		});
	});

	describe('Integration: Full Session Tracking Flow', () => {
		const isUnix = process.platform !== 'win32';

		it('should complete full session tracking flow on Unix', () => {
			if (!isUnix) {
				return;
			}

			// Simulate the complete flow:
			// 1. AI calls ace_search and gets session_id
			const aceSearchResponse = {
				results: [],
				session_id: 'integration-test-uuid',
			};

			// 2. AI works on the task...

			// 3. Stop hook generates AI-Trail summary (no session_id)
			const status = 'completed';
			const loopCount = 0;

			if (status === 'completed' && loopCount === 0) {
				const summary = 'MCP:10 Shell:5 Edits:3 Responses:2';
				const gitBranch = 'main';
				const gitHash = 'abc123';

				const msg = `Session complete. AI-Trail: ${summary}. Git: ${gitBranch} (${gitHash}). Call ace_learn to capture patterns.`;
				const output = { followup_message: msg };

				// Verify output message does NOT contain session_id
				expect(output.followup_message).toContain('AI-Trail:');
				expect(output.followup_message).not.toContain('session_id=');
			}

			// 4. AI sees message and calls ace_learn with remembered session_id
			const aceLearnCall = {
				task: 'Test task',
				trajectory: ['Step 1'],
				success: true,
				output: 'Done',
				git: { commit_hash: 'abc123', branch: 'main' },
				session_id: aceSearchResponse.session_id, // AI remembered this!
			};

			expect(aceLearnCall.session_id).toBe('integration-test-uuid');
		});

		it('should not process when status is not completed', () => {
			const status: string = 'running';
			const loopCount: number = 0;

			// Should not generate message (simulates hook logic)
			const shouldGenerate = status === 'completed' && loopCount === 0;

			expect(shouldGenerate).toBe(false);
		});

		it('should not process when loop_count is greater than 0', () => {
			const status: string = 'completed';
			const loopCount: number = 1;

			// Should not generate message (simulates hook logic)
			const shouldGenerate = status === 'completed' && loopCount === 0;

			expect(shouldGenerate).toBe(false);
		});
	});

	describe('Actual Script File Content Verification', () => {
		it('should verify Unix stop hook script does NOT handle session_id', () => {
			const projectRoot = path.resolve(__dirname, '../../../..');
			const scriptPath = path.join(projectRoot, '.cursor', 'scripts', 'ace_stop_hook.sh');

			if (fs.existsSync(scriptPath)) {
				const content = fs.readFileSync(scriptPath, 'utf-8');

				expect(content).not.toContain('conversation_id');
				expect(content).not.toContain('session_id');
				expect(content).toContain('status');
				expect(content).toContain('loop_count');
				expect(content).toContain('followup_message');
				expect(content).toContain('AI-Trail:');
			}
		});

		it('should verify rules file has correct session_id instructions', () => {
			const projectRoot = path.resolve(__dirname, '../../../..');
			const rulesPath = path.join(projectRoot, '.cursor', 'rules', 'ace-patterns.mdc');

			if (fs.existsSync(rulesPath)) {
				const content = fs.readFileSync(rulesPath, 'utf-8');

				expect(content).toContain('session_id');
				expect(content).toContain('ace_search');
				expect(content).toContain('ace_learn');
				expect(content).toContain('Remember session_id' || 'Note the `session_id`');
			}
		});
	});

	describe('Edge Cases', () => {
		it('should handle null session_id in ace_learn', () => {
			const aceLearnCall = {
				task: 'Test',
				trajectory: [],
				success: true,
				output: 'Done',
				git: { commit_hash: 'abc', branch: 'main' },
				session_id: null,
			};

			expect(aceLearnCall.session_id).toBeNull();
			// Server should handle null session_id gracefully
		});

		it('should handle undefined session_id in ace_learn', () => {
			const aceLearnCall: any = {
				task: 'Test',
				trajectory: [],
				success: true,
				output: 'Done',
				git: { commit_hash: 'abc', branch: 'main' },
			};

			expect(aceLearnCall.session_id).toBeUndefined();
			// Server should handle missing session_id gracefully
		});

		it('should handle empty string session_id', () => {
			const aceLearnCall = {
				task: 'Test',
				trajectory: [],
				success: true,
				output: 'Done',
				git: { commit_hash: 'abc', branch: 'main' },
				session_id: '',
			};

			expect(aceLearnCall.session_id).toBe('');
			// Server should handle empty session_id gracefully
		});

		it('should handle special characters in session_id', () => {
			const sessionId = 'session-with-special_chars.123-abc';

			// Should be properly handled in JSON
			const aceLearnCall = {
				session_id: sessionId,
			};

			const json = JSON.stringify(aceLearnCall);
			const parsed = JSON.parse(json);
			expect(parsed.session_id).toBe(sessionId);
		});

		it('should handle very long session_id', () => {
			const sessionId = 'a'.repeat(1000);

			const aceLearnCall = {
				session_id: sessionId,
			};

			expect(aceLearnCall.session_id).toBe(sessionId);
			expect(aceLearnCall.session_id.length).toBe(1000);
		});
	});
});
